{"version":3,"sources":["/Users/thomas.kellermeier/work/tooling/eslint-seatbelt/dist/api.js","../src/FileLock.ts"],"names":[],"mappings":"AAAA;AACE;AACA;AACF,sDAA4B;AAC5B;AACE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACF,sDAA4B;AAC5B;AACA;AC3BA,wBAAkE;AAElE,IAAM,EAAE,OAAA,EAAS,MAAA,EAAQ,OAAO,EAAA,EAAI,aAAA;AAEpC,IAAM,WAAA,EAAa,IAAI,UAAA,CAAW,IAAI,iBAAA,CAAkB,CAAC,CAAC,CAAA;AAGnD,IAAM,SAAA,EAAN,MAAe;AAAA,EAEpB,WAAA,CAA4B,QAAA,EAAkB;AAAlB,IAAA,IAAA,CAAA,SAAA,EAAA,QAAA;AAAA,EAAmB;AAAA,EADvC;AAAA,EAGR,OAAA,CAAA,EAAU;AACR,IAAA,IAAA,CAAK,eAAA,CAAgB,CAAA;AACrB,IAAA,IAAI;AACF,MAAA,IAAA,CAAK,GAAA,EAAK,0BAAA,IAAS,CAAK,QAAA,EAAU,QAAA,EAAU,OAAA,EAAS,MAAM,CAAA;AAC3D,MAAA,OAAO,IAAA;AAAA,IACT,EAAA,MAAA,CAAS,CAAA,EAAG;AACV,MAAA,GAAA,CAAI,sCAAA,CAAQ,EAAG,QAAQ,CAAA,EAAG;AACxB,QAAA,OAAO,KAAA;AAAA,MACT;AACA,MAAA,MAAM,CAAA;AAAA,IACR;AAAA,EACF;AAAA,EAEA,QAAA,CAAS,SAAA,EAAmB;AAC1B,IAAA,MAAM,SAAA,EAAW,IAAA,CAAK,GAAA,CAAI,EAAA,EAAI,SAAA;AAC9B,IAAA,MAAA,CAAO,CAAC,IAAA,CAAK,OAAA,CAAQ,CAAA,EAAG;AACtB,MAAA,GAAA,CAAI,IAAA,CAAK,GAAA,CAAI,EAAA,EAAI,QAAA,EAAU;AACzB,QAAA,MAAM,IAAI,KAAA,CAAM,CAAA,8BAAA,EAAiC,IAAA,CAAK,QAAQ,CAAA,CAAA;AAChE,MAAA;AACgC,MAAA;AAClC,IAAA;AACF,EAAA;AAEW,EAAA;AACU,IAAA;AACrB,EAAA;AAES,EAAA;AACoB,IAAA;AACR,MAAA;AACG,MAAA;AACV,MAAA;AACZ,IAAA;AACF,EAAA;AAEkB,EAAA;AACW,IAAA;AACf,MAAA;AACkB,QAAA;AAC5B,MAAA;AACF,IAAA;AACF,EAAA;AACF;ADsBuE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"/Users/thomas.kellermeier/work/tooling/eslint-seatbelt/dist/api.js","sourcesContent":[null,"import { openSync, writeSync, closeSync, constants, rmSync } from \"node:fs\"\nimport { isErrno } from \"./errorHanding\"\nconst { O_CREAT, O_EXCL, O_RDWR } = constants\n\nconst waitBuffer = new Int32Array(new SharedArrayBuffer(4))\n\n/** Uses posix open(2) O_EXCL to implement a multi-process mutual exclusion lock. */\nexport class FileLock {\n  private fd: number | undefined\n  constructor(public readonly filename: string) {}\n\n  tryLock() {\n    this.assertNotLocked()\n    try {\n      this.fd = openSync(this.filename, O_CREAT | O_EXCL | O_RDWR)\n      return true\n    } catch (e) {\n      if (isErrno(e, \"EEXIST\")) {\n        return false\n      }\n      throw e\n    }\n  }\n\n  waitLock(timeoutMs: number) {\n    const deadline = Date.now() + timeoutMs\n    while (!this.tryLock()) {\n      if (Date.now() > deadline) {\n        throw new Error(`Timed out waiting for lock on ${this.filename}`)\n      }\n      Atomics.wait(waitBuffer, 0, 0, 1)\n    }\n  }\n\n  isLocked() {\n    return this.fd !== undefined\n  }\n\n  unlock() {\n    if (this.fd !== undefined) {\n      closeSync(this.fd)\n      rmSync(this.filename)\n      this.fd = undefined\n    }\n  }\n\n  assertNotLocked() {\n    if (this.fd !== undefined) {\n      throw new Error(\n        `FileLock \"${this.filename}\" is already locked by this process [pid ${process.pid}]`,\n      )\n    }\n  }\n}\n"]}