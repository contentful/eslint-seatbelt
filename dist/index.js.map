{"version":3,"sources":["/Users/thomas.kellermeier/work/tooling/eslint-seatbelt/dist/index.js","../src/pluginGlobals.ts","../src/SeatbeltProcessor.ts","../src/rules/configure.ts","../src/index.ts"],"names":["name","version","allowIncrease"],"mappings":"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","file":"/Users/thomas.kellermeier/work/tooling/eslint-seatbelt/dist/index.js","sourcesContent":[null,"/**\n * Facilitates caching and passing of state between different parts of the plugin.\n */\n\nimport {\n  FallbackEnv,\n  logStderr,\n  padVarName,\n  SEATBELT_VERBOSE,\n  SeatbeltArgs,\n  SeatbeltConfig,\n  SeatbeltConfigWithPwd,\n  SeatbeltEnv,\n} from \"./SeatbeltConfig\"\nimport { SeatbeltFile } from \"./SeatbeltFile\"\nimport { name, version } from \"../package.json\"\nimport fs from \"node:fs\"\n\nlet ANY_CONFIG_DISABLED = false\nlet LAST_VERBOSE_ARGS: SeatbeltArgs | undefined\nconst VERBOSE_SEATBELT_FILES = new Set<string>()\nconst CLI_ARGS = new Set<SeatbeltArgs>()\n\nconst EMPTY_CONFIG: SeatbeltConfig = {}\nconst argsCache = new WeakMap<SeatbeltConfig, SeatbeltArgs>()\nconst seatbeltFileCache = new Map<string, SeatbeltFile>()\nconst mergedConfigCache = new WeakMap<\n  /* settings.seatbelt */ SeatbeltConfig,\n  WeakMap</* from rule settings override*/ SeatbeltConfig, SeatbeltConfig>\n>()\n\nlet envFallbackConfig: SeatbeltConfig | undefined\nlet envOverrideConfig: SeatbeltConfigWithPwd | undefined\nlet hasAnyEnvVars = false\nlet lastLintedFile: { filename: string; args: SeatbeltArgs } | undefined\nconst temporaryFileArgs = new Map<string, SeatbeltArgs>()\n\nfunction getProcessEnvFallbackConfig(): SeatbeltConfig {\n  if (!envFallbackConfig) {\n    envFallbackConfig = SeatbeltConfig.fromFallbackEnv(\n      process.env as FallbackEnv,\n    )\n    hasAnyEnvVars = Object.keys(envFallbackConfig).length > 0\n  }\n  return envFallbackConfig\n}\n\nfunction getProcessEnvOverrideConfig(): SeatbeltConfigWithPwd {\n  if (!envOverrideConfig) {\n    envOverrideConfig = SeatbeltConfig.fromEnvOverrides(\n      process.env as SeatbeltEnv,\n    )\n    ANY_CONFIG_DISABLED ||= envOverrideConfig.disable ?? false\n    hasAnyEnvVars = Object.keys(envOverrideConfig).length > 0\n  }\n  return envOverrideConfig\n}\n\nexport function ruleOverrideConfigToArgs(\n  settingsConfig: SeatbeltConfig | undefined,\n  ruleOverrideConfig: SeatbeltConfig | undefined,\n): SeatbeltArgs {\n  if (settingsConfig && ruleOverrideConfig) {\n    let settingsConfigMergeMap = mergedConfigCache.get(settingsConfig)\n    if (!settingsConfigMergeMap) {\n      settingsConfigMergeMap = new WeakMap()\n      mergedConfigCache.set(settingsConfig, settingsConfigMergeMap)\n    }\n    let mergedConfig = settingsConfigMergeMap.get(ruleOverrideConfig)\n    if (!mergedConfig) {\n      mergedConfig = { ...settingsConfig, ...ruleOverrideConfig }\n      settingsConfigMergeMap.set(ruleOverrideConfig, mergedConfig)\n    }\n    return configToArgs(mergedConfig)\n  }\n  return configToArgs(ruleOverrideConfig ?? settingsConfig ?? EMPTY_CONFIG)\n}\n\nfunction configToArgs(config: SeatbeltConfig): SeatbeltArgs {\n  let args = argsCache.get(config)\n  if (!args) {\n    const compiledConfig = {\n      ...getProcessEnvFallbackConfig(),\n      ...config,\n      ...getProcessEnvOverrideConfig(),\n    }\n    args = SeatbeltArgs.fromConfig(compiledConfig)\n    ANY_CONFIG_DISABLED ||= args.disable\n    if (args.verbose) {\n      LAST_VERBOSE_ARGS = args\n      VERBOSE_SEATBELT_FILES.add(args.seatbeltFile)\n      if (!args.disable) {\n        logConfig(args, config)\n      }\n    }\n    argsCache.set(config, args)\n  }\n  return args\n}\n\nconst configureRuleName = `${name}/configure`\n\nfunction logRuleSetupHint() {\n  logStderr(\n    `\nMake sure you have rule ${configureRuleName} enabled in your ESLint config for all files:\n\n  rules: {\n    // ...\n    \"${configureRuleName}\": \"error\",\n  }\n\nDocs: https://github.com/justjake/${name}#setup`,\n  )\n}\n\nfunction logConfig(args: SeatbeltArgs, baseConfig: SeatbeltConfig) {\n  const log = SeatbeltArgs.getLogger(args)\n  SeatbeltConfig.fromFallbackEnv(process.env as FallbackEnv, log)\n  for (const [key, value] of Object.entries(baseConfig)) {\n    log(`${padVarName(\"ESLint settings\")} config.${key} =`, value)\n  }\n  SeatbeltConfig.fromEnvOverrides(process.env as SeatbeltEnv, log)\n}\n\nexport function pushFileArgs(filename: string, args: SeatbeltArgs) {\n  lastLintedFile = { filename, args }\n  temporaryFileArgs.set(filename, args)\n  if (isEslintCli()) {\n    CLI_ARGS.add(args)\n  }\n}\n\nexport function popFileArgs(filename: string): SeatbeltArgs {\n  const args = temporaryFileArgs.get(filename)\n  temporaryFileArgs.delete(filename)\n  if (args) {\n    return args\n  }\n\n  if (lastLintedFile?.filename === filename) {\n    // When there is a fatal TS error, eslint doesn't call configure.create() but still\n    // runs the postprocessor, i.e. `temporaryFileArgs` is empty when trying to get the\n    // args for the processed file. As a fallback, we try to use the once from the previous\n    // run.\n    return lastLintedFile.args\n  }\n\n  if (!hasAnyEnvVars) {\n    if (lastLintedFile) {\n      logStderr(\n        `WARNING: last configured by file \\`${lastLintedFile.filename}\\` but linting file \\`${filename}\\`.\nYou may have rule ${configureRuleName} enabled for some files, but not this one.\n`.trim(),\n      )\n    } else {\n      logStderr(\n        `WARNING: rule ${configureRuleName} not enabled in ESLint config and no SEATBELT environment variables set`,\n      )\n    }\n    logRuleSetupHint()\n  }\n  return configToArgs(EMPTY_CONFIG)\n}\n\nexport function getSeatbeltFile(filename: string): SeatbeltFile {\n  let seatbeltFile = seatbeltFileCache.get(filename)\n  if (!seatbeltFile) {\n    seatbeltFile = SeatbeltFile.openSync(filename)\n    seatbeltFileCache.set(filename, seatbeltFile)\n  }\n  return seatbeltFile\n}\n\nlet didRegisterProcessExitHandler = false\n\ntype RunContext = {\n  runner: \"eslint-cli\" | \"editor\" | \"unknown\"\n  inEditorTerminal?: boolean\n  vscodeLike?: boolean\n  ci?: boolean\n  npmLifecycleScript?: string\n}\n\nfunction detectRunContext(): RunContext {\n  const isVscodeExtension = Boolean(process.env.VSCODE_IPC_HOOK)\n  const isVscodeShell = process.env.TERM_PROGRAM === \"vscode\"\n  const isEslintCli = process.argv.some(\n    (arg) =>\n      arg.endsWith(\"bin/eslint.js\") || arg.includes(\"node_modules/eslint/\"),\n  )\n\n  return {\n    runner: isVscodeExtension\n      ? \"editor\"\n      : isEslintCli\n        ? \"eslint-cli\"\n        : \"unknown\",\n    inEditorTerminal: isVscodeShell,\n    npmLifecycleScript: process.env.npm_lifecycle_script,\n    ci: Boolean(process.env.CI),\n  }\n}\n\nlet runContext: RunContext | undefined\nfunction getRunContext(): RunContext {\n  if (!runContext) {\n    runContext = detectRunContext()\n  }\n  return runContext\n}\n\nconst pluginStats = {\n  processorRuns: 0,\n  ruleRuns: 0,\n  removedFiles: 0,\n}\n\nexport function incrementStat(key: keyof typeof pluginStats, value = 1) {\n  pluginStats[key] += value\n}\n\nexport function onPreprocess(_filename: string) {\n  incrementStat(\"processorRuns\")\n}\n\nexport function onPostprocess(_filename: string) {}\n\nexport function onConfigureRule(_filename: string) {\n  incrementStat(\"ruleRuns\")\n}\n\nexport function registerEslintCliExitHandler() {\n  if (ANY_CONFIG_DISABLED) {\n    return\n  }\n  if (didRegisterProcessExitHandler) {\n    return\n  }\n  didRegisterProcessExitHandler = true\n  const runContext = detectRunContext()\n  if (isEslintCli()) {\n    process.once(\"exit\", () => handleEslintCliExit(runContext))\n  }\n}\n\n// Detect configuration errors\nfunction handleEslintCliExit(_runContext: RunContext) {\n  if (ANY_CONFIG_DISABLED) {\n    return\n  }\n\n  cleanUpRemovedFiles()\n\n  if (LAST_VERBOSE_ARGS) {\n    logEslintRunSummary()\n  }\n}\n\nfunction cleanUpRemovedFiles() {\n  for (const args of CLI_ARGS) {\n    const seatbeltFile = getSeatbeltFile(args.seatbeltFile)\n    // TODO: args.threadsafe\n    seatbeltFile.readSync()\n    for (const filename of seatbeltFile.filenames()) {\n      if (!fs.existsSync(filename)) {\n        seatbeltFile.removeFile(filename, args)\n        incrementStat(\"removedFiles\")\n      }\n    }\n    seatbeltFile.writeSync()\n  }\n}\n\nfunction logEslintRunSummary() {\n  const log = LAST_VERBOSE_ARGS\n    ? SeatbeltArgs.getLogger(LAST_VERBOSE_ARGS)\n    : logStderr\n\n  const seatbeltFiles = Array.from(VERBOSE_SEATBELT_FILES).map(getSeatbeltFile)\n  const ruleInfo = new Map<string, { allowed: number; inFiles: number }>()\n  const totalInfo = { allowed: 0, inFiles: 0 }\n  for (const seatbeltFile of seatbeltFiles) {\n    for (const filename of seatbeltFile.filenames()) {\n      const maxErrors = seatbeltFile.getMaxErrors(filename)\n      if (maxErrors) {\n        for (const [ruleId, errorCount] of maxErrors.entries()) {\n          const info = getDefault(ruleInfo, ruleId, () => ({\n            allowed: 0,\n            inFiles: 0,\n          }))\n          info.allowed += errorCount\n          info.inFiles++\n          totalInfo.allowed += errorCount\n          totalInfo.inFiles++\n        }\n      }\n    }\n  }\n\n  const ruleStatsMessages: string[] = []\n  ruleStatsMessages.push(\n    `${SEATBELT_VERBOSE}: ${name}@${version} checked ${pluginStats.processorRuns} source files\\n`,\n  )\n\n  const seatbeltFileCount =\n    seatbeltFiles.length === 1\n      ? \"seatbelt file\"\n      : `${seatbeltFiles.length} seatbelt files`\n\n  if (pluginStats.removedFiles > 0) {\n    ruleStatsMessages.push(\n      `Removed ${pluginStats.removedFiles} non-existent source files from ${seatbeltFileCount}\\n`,\n    )\n  }\n  ruleStatsMessages.push(`Allowed errors in ${seatbeltFileCount}:\\n`)\n  for (const ruleId of Array.from(ruleInfo.keys()).sort()) {\n    const info = ruleInfo.get(ruleId)!\n    const sourceFilesCount =\n      info.inFiles === 1 ? \"1 source file\" : `${info.inFiles} source files`\n    ruleStatsMessages.push(\n      `  ${ruleId}: ${info.allowed} allowed in ${sourceFilesCount}\\n`,\n    )\n  }\n  log(ruleStatsMessages.join(\"\"))\n}\n\nexport function hasProcessorRun() {\n  return pluginStats.processorRuns > 0\n}\n\nexport function anyDisabled() {\n  return ANY_CONFIG_DISABLED\n}\n\nfunction getDefault<K, V>(map: Map<K, V>, key: K, defaultValue: () => V) {\n  if (!map.has(key)) {\n    const value = defaultValue()\n    map.set(key, value)\n    return value\n  }\n  return map.get(key)!\n}\n\nexport function isEslintCli() {\n  return getRunContext().runner === \"eslint-cli\"\n}\n","import type { Linter } from \"eslint\"\nimport packageJson from \"../package.json\"\nimport { RuleId, SeatbeltFile } from \"./SeatbeltFile\"\nimport {\n  formatFilename,\n  formatRuleId,\n  SEATBELT_FROZEN,\n  SEATBELT_INCREASE,\n  SeatbeltArgs,\n} from \"./SeatbeltConfig\"\nimport * as pluginGlobals from \"./pluginGlobals\"\nimport { appendErrorContext } from \"./errorHanding\"\n\nconst { name, version } = packageJson\n\n/**\n * seatbelt works by observing the list messages and filtering out\n * messages that are allowed by the seatbelt file. Note that ESLint is a\n * completely synchronous codebase, so we also need to be synchronous.\n *\n * https://eslint.org/docs/latest/extend/custom-processors\n */\nexport const SeatbeltProcessor: Linter.Processor = {\n  supportsAutofix: true,\n  meta: {\n    name,\n    version,\n  },\n  // takes text of the file and filename\n  preprocess(text, filename) {\n    pluginGlobals.onPreprocess(filename)\n    // We don't need to do anything here, pass through the data unchanged.\n    return [text]\n  },\n\n  /** Where the action happens. */\n  postprocess(messagesPerSection, filename) {\n    pluginGlobals.onPostprocess(filename)\n    // takes a Message[][] and filename\n    // `messages` argument contains two-dimensional array of Message objects\n    // where each top-level array item contains array of lint messages related\n    // to the text that was returned in array from preprocess() method\n    if (messagesPerSection.length !== 1) {\n      throw new Error(\n        `${name} bug: expected preprocess to return 1 section, got ${messagesPerSection.length}`,\n      )\n    }\n    const messages = messagesPerSection[0]\n\n    const args = pluginGlobals.popFileArgs(filename)\n    if (args.disable) {\n      return messages\n    }\n\n    const seatbeltFile = pluginGlobals.getSeatbeltFile(args.seatbeltFile)\n    if (args.threadsafe || !pluginGlobals.isEslintCli()) {\n      seatbeltFile.readSync()\n    }\n    const ruleToErrorCount = countRuleIds(messages)\n    const verboseOnce = args.verbose ? createOnce<RuleId>() : () => false\n    try {\n      const transformed = transformMessages(\n        args,\n        seatbeltFile,\n        filename,\n        messages,\n        ruleToErrorCount,\n        verboseOnce,\n      )\n\n      try {\n        // Ideally we could find a way to batch writes until all linting is finished, but I haven't found a\n        // good way to schedule our code to run after all files but before\n        // ESLint returns to its caller or exits.\n        const additionalMessages = maybeWriteStateUpdate(\n          args,\n          seatbeltFile,\n          filename,\n          ruleToErrorCount,\n        )\n\n        if (additionalMessages) {\n          return transformed.concat(additionalMessages)\n        } else {\n          return transformed\n        }\n      } catch (e) {\n        return [...transformed, handleProcessingError(filename, e)]\n      }\n    } catch (e) {\n      return [...messages, handleProcessingError(filename, e)]\n    }\n  },\n}\n\nfunction createOnce<T>(): (value: T) => boolean {\n  const seen = new Set<T>()\n  return (value: T) => {\n    if (seen.has(value)) {\n      return false\n    }\n    seen.add(value)\n    return true\n  }\n}\n\nfunction transformMessages(\n  args: SeatbeltArgs,\n  seatbeltFile: SeatbeltFile,\n  filename: string,\n  messages: Linter.LintMessage[],\n  ruleToErrorCount: Map<RuleId, number>,\n  verboseOnce: (ruleId: RuleId) => boolean,\n) {\n  if (args.disable) {\n    return messages\n  }\n\n  const ruleToMaxErrorCount = seatbeltFile.getMaxErrors(filename)\n  const allowIncrease =\n    args.allowIncreaseRules === \"all\" || args.allowIncreaseRules.size > 0\n  if (!ruleToMaxErrorCount && !allowIncrease) {\n    // We have no state related to this file, so no need to consider it.\n    return messages\n  }\n\n  return messages.map((message) => {\n    if (message.ruleId === null) {\n      SeatbeltArgs.verboseLog(\n        args,\n        () =>\n          `${formatFilename(filename)}:${message.line}:${message.column}: cannot transform message with null ruleId`,\n      )\n      return message\n    }\n\n    if (!isCountableLintError(message)) {\n      return message\n    }\n\n    const errorCount = ruleToErrorCount.get(message.ruleId)\n    if (errorCount === undefined) {\n      throw new Error(\n        `${name} bug: errorCount not found for rule ${message.ruleId}`,\n      )\n    }\n\n    const maxErrorCount = ruleToMaxErrorCount?.get(message.ruleId) ?? 0\n    const allowIncrease = SeatbeltArgs.ruleSetHas(\n      args.allowIncreaseRules,\n      message.ruleId,\n    )\n    if (maxErrorCount === 0 && !allowIncrease) {\n      // Rule not controlled by seatbelt, just pass it through unchanged.\n      return message\n    } else if (errorCount > maxErrorCount) {\n      if (allowIncrease) {\n        // Rule is allowed to increase from 0 -> any, so it should become a warning.\n        return messageOverMaxErrorCountButIncreaseAllowed(\n          message,\n          errorCount,\n          maxErrorCount,\n        )\n      }\n\n      // Rule controlled by seatbelt, but too many errorCount:\n      // keep the message as an error, but add a notice about seatbelt\n      // violation count\n      if (verboseOnce(message.ruleId)) {\n        SeatbeltArgs.verboseLog(\n          args,\n          () =>\n            `${formatFilename(filename)}: ${formatRuleId(message.ruleId)}: error: ${errorCount} ${pluralErrors(errorCount)} found > max ${maxErrorCount}`,\n        )\n      }\n      return messageOverMaxErrorCount(message, errorCount, maxErrorCount)\n    } else if (errorCount === maxErrorCount) {\n      // For rules under the limit, turn errors into warnings.\n      // Add an appropriate notice about seatbelt violation status.\n      if (verboseOnce(message.ruleId)) {\n        SeatbeltArgs.verboseLog(\n          args,\n          () =>\n            `${formatFilename(filename)}: ${formatRuleId(message.ruleId)}: ok: ${errorCount} ${pluralErrors(errorCount)} found == max ${maxErrorCount}`,\n        )\n      }\n\n      return messageAtMaxErrorCount(message, errorCount)\n    } else {\n      if (args.frozen) {\n        // We're frozen, so it's actually an error to decrease the error count.\n        return messageFrozenUnderMaxErrorCount(\n          message,\n          filename,\n          errorCount,\n          maxErrorCount,\n        )\n      }\n      // Can tighten the seatbelt.\n      return messageUnderMaxErrorCount(message, errorCount, maxErrorCount)\n    }\n  })\n}\n\nfunction isCountableLintError(\n  message: Linter.LintMessage | Linter.SuppressedLintMessage,\n): message is Linter.LintMessage & { ruleId: string } {\n  if (!message.severity || message.severity < 2) {\n    return false\n  }\n\n  if (\n    (\"suppressions\" satisfies keyof Linter.SuppressedLintMessage) in message &&\n    message.suppressions.length > 0\n  ) {\n    return false\n  }\n\n  if (!message.ruleId) {\n    return false\n  }\n\n  return true\n}\n\nfunction countRuleIds(messages: Linter.LintMessage[]): Map<RuleId, number> {\n  const ruleToErrorCount = new Map<RuleId, number>()\n  messages.forEach((message) => {\n    if (!isCountableLintError(message)) {\n      return\n    }\n    ruleToErrorCount.set(\n      message.ruleId,\n      (ruleToErrorCount.get(message.ruleId) ?? 0) + 1,\n    )\n  })\n  return ruleToErrorCount\n}\n\nfunction maybeWriteStateUpdate(\n  args: SeatbeltArgs,\n  stateFile: SeatbeltFile,\n  filename: string,\n  ruleToErrorCount: Map<RuleId, number>,\n): Linter.LintMessage[] | undefined {\n  if (args.disable) {\n    return\n  }\n  // Used to disable updates but still run checks (the general `disable` turns off everything)\n  if (args.disableInEditor) {\n    return\n  }\n  if (args.threadsafe) {\n    // TODO: Implement locking\n    // For now just refresh the file.\n    stateFile.readSync()\n  }\n\n  const ruleToMaxErrorCount = stateFile.getMaxErrors(filename)\n  const { removedRules } = stateFile.updateMaxErrors(\n    filename,\n    args,\n    ruleToErrorCount,\n  )\n  if (!args.frozen) {\n    stateFile.flushChanges()\n  } else if (removedRules && removedRules.size > 0) {\n    // We didn't actually update the state file in this case.\n    // We need to add an original error message about the inconsistent state.\n    return Array.from(removedRules).map((ruleId) => {\n      const maxErrorCount = ruleToMaxErrorCount?.get(ruleId)\n      if (maxErrorCount === undefined) {\n        throw new Error(\n          `${name} bug: maxErrorCount not found for removed frozen rule ${ruleId}`,\n        )\n      }\n      const message: Linter.LintMessage = {\n        ruleId,\n        column: 0,\n        line: 1,\n        severity: 2,\n        message: messageFrozenUnderMaxErrorCountText(\n          filename,\n          0,\n          maxErrorCount,\n        ),\n      }\n      return message\n    })\n  }\n}\n\nfunction messageOverMaxErrorCount(\n  message: Linter.LintMessage,\n  errorCount: number,\n  maxErrorCount: number,\n): Linter.LintMessage {\n  return {\n    ...message,\n    message: `${message.message}\n[${name}]: There are ${errorCount} ${pluralErrors(errorCount)} of this type, but only ${maxErrorCount} are allowed.\nRemove ${errorCount - maxErrorCount} to turn these errors into warnings.\n    `.trim(),\n  }\n}\n\nfunction messageOverMaxErrorCountButIncreaseAllowed(\n  message: Linter.LintMessage,\n  errorCount: number,\n  maxErrorCount: number,\n): Linter.LintMessage {\n  const increaseCount = errorCount - maxErrorCount\n\n  return {\n    ...message,\n    severity: 1,\n    message: `${message.message}\n[${name}]: ${SEATBELT_INCREASE}: Temporarily allowing ${increaseCount} new ${pluralErrors(increaseCount)} of this type.\n    `.trim(),\n  }\n}\n\nfunction messageAtMaxErrorCount(\n  message: Linter.LintMessage,\n  errorCount: number,\n): Linter.LintMessage {\n  return {\n    ...message,\n    severity: 1,\n    message: `${message.message}\n[${name}]: This file is temporarily allowed to have ${errorCount} ${pluralErrors(errorCount)} of this type.\nPlease tend the garden by fixing if you have the time.\n    `.trim(),\n  }\n}\n\nfunction messageUnderMaxErrorCount(\n  message: Linter.LintMessage,\n  errorCount: number,\n  maxErrorCount: number,\n): Linter.LintMessage {\n  const fixed = errorCount - maxErrorCount\n  const fixedMessage = fixed === 1 ? \"one\" : `${fixed} errors`\n  return {\n    ...message,\n    severity: 1,\n    message: `${message.message}\n[${name}]: This file is temporarily allowed to have ${maxErrorCount} ${pluralErrors(maxErrorCount)} of this type.\nThank you for fixing ${fixedMessage}, it really helps.\n    `.trim(),\n  }\n}\n\nfunction messageFrozenUnderMaxErrorCountText(\n  seatbeltFilename: string,\n  errorCount: number,\n  maxErrorCount: number,\n) {\n  const fixed = errorCount - maxErrorCount\n  const fixedMessage = fixed === 1 ? \"error\" : \"errors\"\n  return `\n[${name}]: ${SEATBELT_FROZEN}: Expected ${maxErrorCount} ${pluralErrors(maxErrorCount)}, found ${errorCount}.\nIf you fixed ${fixed} ${fixedMessage}, thank you, but you'll need to update the seatbelt file to match.\nTry running eslint, then committing ${seatbeltFilename}.\n`.trim()\n}\n\nfunction messageFrozenUnderMaxErrorCount(\n  message: Linter.LintMessage,\n  seatbeltFilename: string,\n  errorCount: number,\n  maxErrorCount: number,\n): Linter.LintMessage {\n  return {\n    ...message,\n    severity: 1,\n    message: `${message.message}\\n${messageFrozenUnderMaxErrorCountText(seatbeltFilename, errorCount, maxErrorCount)}`,\n  }\n}\n\nconst alreadyModifiedError = new WeakSet<Error>()\n\nfunction handleProcessingError(\n  filename: string,\n  e: unknown,\n): Linter.LintMessage {\n  if (e instanceof Error && !alreadyModifiedError.has(e)) {\n    alreadyModifiedError.add(e)\n    appendErrorContext(e, `while processing \\`${filename}\\``)\n    appendErrorContext(\n      e,\n      `this may be a bug in ${name}@${version} or a problem with your setup`,\n    )\n  }\n  throw e\n}\n\nfunction pluralErrors(count: number) {\n  return count === 1 ? \"error\" : \"errors\"\n}\n","import type { Rule } from \"eslint\"\nimport { SeatbeltConfigSchema } from \"../jsonSchema/SeatbeltConfigSchema\"\nimport { name } from \"../../package.json\"\nimport { SeatbeltConfig } from \"../SeatbeltConfig\"\nimport * as pluginGlobals from \"../pluginGlobals\"\n\n/**\n * This rule is required to capture the `seatbelt` configuration from the ESLint\n * config.\n */\nexport const configure: Rule.RuleModule = {\n  meta: {\n    docs: {\n      description: `Applies ${name} configuration from ESLint config`,\n      url: `https://github.com/justjake/${name}`,\n    },\n    schema: [SeatbeltConfigSchema],\n  },\n  create(context) {\n    const filename = context.getFilename?.() ?? context.filename\n    pluginGlobals.onConfigureRule(filename)\n\n    const eslintSharedConfigViaShortName = context.settings?.seatbelt as\n      | SeatbeltConfig\n      | undefined\n    const eslintSharedConfigViaPackageName = context.settings?.[name] as\n      | SeatbeltConfig\n      | undefined\n    const eslintSharedConfig =\n      eslintSharedConfigViaShortName ?? eslintSharedConfigViaPackageName\n    const fileOverrideConfig = context.options[0] as SeatbeltConfig | undefined\n    const args = pluginGlobals.ruleOverrideConfigToArgs(\n      eslintSharedConfig,\n      fileOverrideConfig,\n    )\n    pluginGlobals.pushFileArgs(filename, args)\n\n    // No linting happening here.\n    return {}\n  },\n}\n","import type { ESLint, Linter } from \"eslint\"\nimport packageJson from \"../package.json\"\nimport { SeatbeltProcessor } from \"./SeatbeltProcessor\"\nimport { configure } from \"./rules/configure\"\nconst { name, version } = packageJson\n\n/**\n * See the package README for usage instructions.\n * https://github.com/justjake/eslint-seatbelt#readme\n */\nconst plugin = {\n  meta: {\n    name,\n    version,\n  },\n  /**\n   * https://eslint.org/docs/latest/extend/custom-processors\n   */\n  processors: {\n    seatbelt: SeatbeltProcessor,\n  },\n  rules: {\n    configure,\n  },\n  /**\n   *\n   */\n  configs: {\n    /**\n     * Config preset for ESLint 9 and above.\n     *\n     * Usage:\n     *\n     * ```\n     * // eslint.config.js\n     * module.exports = [\n     *   require(\"eslint-seatbelt\").configs.enable,\n     *   // ... your configs\n     * ]\n     */\n    enable: undefined as any as ReturnType<typeof createESLint9Config>,\n    /**\n     * Config preset for ESLint 8 and below.\n     *\n     * Usage:\n     *\n     * ```\n     * // eslintrc.js\n     * module.exports = {\n     *   plugins: [\"eslint-seatbelt\"],\n     *   extends: [\"plugin:eslint-seatbelt/enable-legacy\"],\n     *   // ... your configs\n     * }\n     * ```\n     *\n     * https://eslint.org/docs/latest/use/configure/configuration-files-deprecated#using-a-configuration-from-a-plugin\n     */\n    \"enable-legacy\": undefined as any as ReturnType<typeof createLegacyConfig>,\n  },\n} satisfies ESLint.Plugin & ESLint.Plugin\n\nplugin.configs.enable = createESLint9Config()\nplugin.configs[\"enable-legacy\"] = createLegacyConfig()\n\nfunction createESLint9Config() {\n  const ownPlugin: ESLint.Plugin = plugin\n  return {\n    name: `${name}/enable`,\n    plugins: {\n      [name]: ownPlugin,\n    },\n    rules: {\n      [`${name}/configure`]: \"error\",\n    },\n    processor: `${name}/seatbelt`,\n  } satisfies Linter.Config\n}\n\nfunction createLegacyConfig() {\n  return {\n    plugins: [name],\n    rules: {\n      [`${name}/configure`]: \"error\",\n    },\n    processor: `${name}/seatbelt`,\n  } satisfies Linter.LegacyConfig\n}\n\nexport default plugin\n"]}