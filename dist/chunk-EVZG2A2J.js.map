{"version":3,"sources":["/Users/thomas.kellermeier/work/tooling/eslint-seatbelt/dist/chunk-EVZG2A2J.js","../src/SeatbeltFile.ts","../src/errorHanding.ts"],"names":[],"mappings":"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","file":"/Users/thomas.kellermeier/work/tooling/eslint-seatbelt/dist/chunk-EVZG2A2J.js","sourcesContent":[null,"import * as os from \"node:os\"\nimport * as fs from \"node:fs\"\nimport path, * as nodePath from \"node:path\"\nimport {\n  formatFilename,\n  formatRuleId,\n  SEATBELT_FROZEN,\n  SEATBELT_KEEP,\n  SeatbeltArgs,\n} from \"./SeatbeltConfig\"\nimport { name } from \"../package.json\"\nimport { appendErrorContext, isErrno } from \"./errorHanding\"\n\nexport type SourceFileName = string\nexport type RuleId = string\n\ninterface SeatbeltFileLine {\n  encoded?: string\n  filename: SourceFileName\n  ruleId: RuleId\n  maxErrors: number\n}\n\nexport type SeatbeltFileJson = {\n  filename: SourceFileName\n  data: Record<SourceFileName, Record<RuleId, number>>\n}\n\nfunction encodeLine(line: SeatbeltFileLine): string {\n  const { filename, ruleId, maxErrors } = line\n  return `${JSON.stringify(filename)}\\t${JSON.stringify(ruleId)}\\t${maxErrors}\\n`\n}\n\nfunction decodeLine(line: string, index: number): SeatbeltFileLine {\n  try {\n    const lineParts = line.split(\"\\t\")\n    if (lineParts.length !== 3) {\n      throw new Error(\n        `Expected 3 tab-separated JSON strings, instead have ${lineParts.length}`,\n      )\n    }\n    let filename: string\n    try {\n      filename = JSON.parse(lineParts[0])\n    } catch (e) {\n      appendErrorContext(e, \"at tab-separated column 1 (filename)\")\n      throw e\n    }\n\n    let ruleId: RuleId\n    try {\n      ruleId = JSON.parse(lineParts[1])\n    } catch (e) {\n      appendErrorContext(e, \"at tab-separated column 2 (RuleId)\")\n      throw e\n    }\n\n    let maxErrors: number\n    try {\n      maxErrors = JSON.parse(lineParts[2])\n    } catch (e) {\n      appendErrorContext(e, \"at tab-separated column 3 (maxErrors)\")\n      throw e\n    }\n\n    return {\n      encoded: line,\n      filename,\n      ruleId,\n      maxErrors,\n    }\n  } catch (e) {\n    appendErrorContext(e, `at line ${index + 1}: \\`${line.trim()}\\``)\n    throw e\n  }\n}\n\ninterface SeatbeltStateFileData {\n  maxErrors?: Map<RuleId, number>\n  lines: SeatbeltFileLine[]\n}\n\nconst COMMENT_LINE_REGEX = /^\\s*#/\nconst NON_EMPTY_LINE_REGEX = /\\S+/\n\nconst DEFAULT_FILE_HEADER = `\n# ${name} temporarily allowed errors\n# docs: https://github.com/justjake/${name}#readme\n`.trim()\n\n/**\n * The state file is a Map<filename, Map<ruleId, allowedErrors>>.\n * It is stored in \"tab separated json\" format. This format is chosen over JSON\n * or YAML because each line is independent, which makes resolving merge\n * conflicts much easier than in a syntactically hierarchical format.\n */\nexport class SeatbeltFile {\n  static readSync(filename: string): SeatbeltFile {\n    const text = fs.readFileSync(filename, \"utf8\")\n    try {\n      return SeatbeltFile.parse(filename, text)\n    } catch (e) {\n      appendErrorContext(e, `in seatbelt file \\`${filename}\\``)\n      throw e\n    }\n  }\n\n  /**\n   * Read `filename` if it exists, otherwise create a new empty seatbelt file object\n   * that will write to that filename.\n   */\n  static openSync(filename: string): SeatbeltFile {\n    try {\n      return SeatbeltFile.readSync(filename)\n    } catch (e) {\n      if (isErrno(e, \"ENOENT\")) {\n        return new SeatbeltFile(filename, new Map(), DEFAULT_FILE_HEADER)\n      }\n      throw e\n    }\n  }\n\n  static parse(filename: string, text: string): SeatbeltFile {\n    const data = new Map<SourceFileName, SeatbeltStateFileData>()\n    const split = text.split(/(?<=\\n)/)\n    const lines = split\n      .filter(\n        (line) =>\n          NON_EMPTY_LINE_REGEX.test(line) && !COMMENT_LINE_REGEX.test(line),\n      )\n      .map(decodeLine)\n    const comments = split\n      .filter((line) => COMMENT_LINE_REGEX.test(line))\n      .join(\"\")\n    lines.forEach((line) => {\n      let fileState = data.get(line.filename)\n      if (!fileState) {\n        fileState = { maxErrors: undefined, lines: [] }\n        data.set(line.filename, fileState)\n      }\n      fileState.lines.push(line)\n    })\n    return new SeatbeltFile(filename, data, comments.trim())\n  }\n\n  static fromJSON(json: SeatbeltFileJson): SeatbeltFile {\n    const data = new Map(\n      Object.entries(json.data).map(([filename, maxErrors]) => [\n        filename,\n        { maxErrors: new Map(Object.entries(maxErrors)), lines: [] },\n      ]),\n    )\n    return new SeatbeltFile(json.filename, data)\n  }\n\n  public changed = false\n  private readonly dirname: string\n  private useTempDirForWrites = true\n\n  constructor(\n    public readonly filename: string,\n    protected data: Map<SourceFileName, SeatbeltStateFileData>,\n    public readonly comments: string = \"\",\n  ) {\n    this.filename = path.resolve(this.filename)\n    this.dirname = path.dirname(this.filename)\n  }\n\n  *filenames(): IterableIterator<SourceFileName> {\n    for (const filename of this.data.keys()) {\n      yield this.toAbsolutePath(filename)\n    }\n  }\n\n  getMaxErrors(\n    filename: SourceFileName,\n  ): ReadonlyMap<RuleId, number> | undefined {\n    const fileState = this.data.get(this.toRelativePath(filename))\n    if (!fileState) {\n      return undefined\n    }\n    fileState.maxErrors ??= parseMaxErrors(fileState.lines)\n    return fileState.maxErrors\n  }\n\n  removeFile(filename: SourceFileName, args: SeatbeltArgs) {\n    const relativeFilename = this.toRelativePath(filename)\n    if (!this.data.has(relativeFilename)) {\n      return false\n    }\n\n    SeatbeltArgs.verboseLog(args, () =>\n      args.frozen\n        ? `${formatFilename(filename)}: ${SEATBELT_FROZEN}: didn't remove max errors`\n        : `${formatFilename(filename)}: remove max errors`,\n    )\n\n    if (args.frozen) {\n      return false\n    }\n\n    this.data.delete(relativeFilename)\n    this.changed = true\n    return true\n  }\n\n  updateMaxErrors(\n    filename: SourceFileName,\n    args: SeatbeltArgs,\n    ruleToErrorCount: ReadonlyMap<RuleId, number>,\n  ) {\n    const removedRules = new Set<RuleId>()\n    let increasedRulesCount = 0\n    let decreasedRulesCount = 0\n    this.getMaxErrors(filename)\n    const relativeFilename = this.toRelativePath(filename)\n    const maxErrors =\n      this.data.get(relativeFilename)?.maxErrors ?? new Map<RuleId, number>()\n\n    ruleToErrorCount.forEach((errorCount, ruleId) => {\n      const maxErrorCount = maxErrors.get(ruleId) ?? 0\n      if (errorCount === maxErrorCount) {\n        return\n      }\n\n      if (\n        errorCount < maxErrorCount ||\n        SeatbeltArgs.ruleSetHas(args.allowIncreaseRules, ruleId)\n      ) {\n        SeatbeltArgs.verboseLog(args, () =>\n          args.frozen\n            ? `${formatFilename(filename)}: ${formatRuleId(ruleId)}: ${SEATBELT_FROZEN}: didn't update max errors ${maxErrorCount} -> ${errorCount}`\n            : `${formatFilename(filename)}: ${formatRuleId(ruleId)}: update max errors ${maxErrorCount} -> ${errorCount}`,\n        )\n        maxErrors.set(ruleId, errorCount)\n        if (errorCount > maxErrorCount) {\n          increasedRulesCount++\n        } else {\n          decreasedRulesCount++\n        }\n      }\n    })\n\n    if (args.verbose || args.keepRules !== \"all\") {\n      maxErrors.forEach((maxErrorCount, ruleId) => {\n        const shouldRemove =\n          maxErrorCount === 0 || !ruleToErrorCount.has(ruleId)\n\n        if (!shouldRemove) {\n          return\n        }\n\n        if (SeatbeltArgs.ruleSetHas(args.keepRules, ruleId)) {\n          SeatbeltArgs.verboseLog(\n            args,\n            () =>\n              `${formatFilename(filename)}: ${formatRuleId(ruleId)}: ${SEATBELT_KEEP}: didn't update max errors ${maxErrorCount} -> ${0}`,\n          )\n          return\n        }\n\n        SeatbeltArgs.verboseLog(args, () =>\n          args.frozen\n            ? `${formatFilename(filename)}: ${formatRuleId(ruleId)}: ${SEATBELT_FROZEN}: didn't update max errors ${maxErrorCount} -> ${0}`\n            : `${formatFilename(filename)}: ${formatRuleId(ruleId)}: update max errors ${maxErrorCount} -> ${0}`,\n        )\n\n        maxErrors.delete(ruleId)\n        removedRules.add(ruleId)\n      })\n    }\n\n    const changed =\n      increasedRulesCount > 0 ||\n      decreasedRulesCount > 0 ||\n      removedRules.size > 0\n    if (changed && !args.frozen) {\n      const file = this.data.get(relativeFilename)\n      if (file) {\n        file.maxErrors = maxErrors\n      } else {\n        this.data.set(relativeFilename, {\n          maxErrors,\n          lines: [],\n        })\n      }\n      this.changed = true\n    }\n\n    return { removedRules, increasedRulesCount, decreasedRulesCount }\n  }\n\n  toDataString(): string {\n    const lines: string[] = []\n    this.data.forEach((fileState, filename) => {\n      if (fileState.maxErrors) {\n        // Serialize maxErrors map structure if it exists, since it may have changes.\n        fileState.lines = []\n        fileState.maxErrors.forEach((maxErrorCount, ruleId) => {\n          fileState.lines.push({ filename, ruleId, maxErrors: maxErrorCount })\n        })\n        fileState.lines.sort((a, b) =>\n          a.ruleId === b.ruleId ? 0 : a.ruleId < b.ruleId ? -1 : 1,\n        )\n      }\n      fileState.lines.forEach((line) => {\n        const encoded = (line.encoded ??= encodeLine(line))\n        lines.push(encoded)\n      })\n    })\n    lines.sort()\n    if (this.comments) {\n      return this.comments + \"\\n\\n\" + lines.join(\"\")\n    } else {\n      return lines.join(\"\")\n    }\n  }\n\n  readSync() {\n    const nextStateFile = SeatbeltFile.openSync(this.filename)\n    if (nextStateFile) {\n      this.data = nextStateFile.data\n      this.changed = false\n      return true\n    }\n    return false\n  }\n\n  flushChanges() {\n    if (this.changed) {\n      this.writeSync()\n      this.changed = false\n      return { updated: true }\n    }\n    return { updated: false }\n  }\n\n  writeSync() {\n    const dataString = this.toDataString()\n    const dir = nodePath.dirname(this.filename)\n    const base = nodePath.basename(this.filename)\n    const tempFile = nodePath.join(\n      this.useTempDirForWrites ? os.tmpdir() : dir,\n      `.${base}.wip${process.pid}.${Date.now()}.tmp`,\n    )\n    fs.mkdirSync(dir, { recursive: true })\n    fs.writeFileSync(tempFile, dataString, \"utf8\")\n    try {\n      fs.renameSync(tempFile, this.filename)\n    } catch (error) {\n      // If $TMPDIR is on a different filesystem from the git repo, we won't be\n      // able to move the tempfile over the existing file.\n      //\n      // In such cases copy & remove the tempfile instead, and then prefer to create\n      // tempfiles in the desination dir.\n      //\n      // https://github.com/justjake/eslint-seatbelt/issues/7\n      if (isErrno(error, 'EXDEV')) {\n        this.useTempDirForWrites = false\n        fs.copyFileSync(tempFile, this.filename)\n        fs.rmSync(tempFile)\n        return\n      }\n      throw error\n    }\n  }\n\n  toJSON(): SeatbeltFileJson {\n    const data = Object.fromEntries(\n      Array.from(this.data.keys()).map((filename) => {\n        const maxErrors = this.getMaxErrors(filename)\n        if (!maxErrors) {\n          throw new Error(`${name} bug: expected errors for existing key`)\n        }\n        return [filename, Object.fromEntries(maxErrors)]\n      }),\n    )\n    return { filename: this.filename, data }\n  }\n\n  toRelativePath(filename: string) {\n    if (!nodePath.isAbsolute(filename)) {\n      return filename\n    }\n    return nodePath.relative(this.dirname, filename)\n  }\n\n  toAbsolutePath(filename: string) {\n    if (nodePath.isAbsolute(filename)) {\n      return filename\n    }\n    return nodePath.resolve(this.dirname, filename)\n  }\n}\n\nfunction parseMaxErrors(lines: SeatbeltFileLine[]): Map<RuleId, number> {\n  const maxErrors = new Map<RuleId, number>()\n  lines.forEach((line) => {\n    maxErrors.set(line.ruleId, line.maxErrors)\n  })\n  return maxErrors\n}\n","export function appendErrorContext(error: unknown, context: string) {\n  if (error instanceof Error) {\n    error.message += `\\n  ${context}`\n  }\n}\n\nexport function isErrno(\n  error: unknown,\n  code: string,\n): error is NodeJS.ErrnoException {\n  return error instanceof Error && \"code\" in error && error.code === code\n}\n"]}